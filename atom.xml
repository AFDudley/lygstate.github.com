<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Octopress Blog]]></title>
  <link href="http://lygstate.github.com/atom.xml" rel="self"/>
  <link href="http://lygstate.github.com/"/>
  <updated>2013-01-14T21:11:52+08:00</updated>
  <id>http://lygstate.github.com/</id>
  <author>
    <name><![CDATA[Yonggang Luo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Windows Vista/2008/7全系列（x86、x64）ISO镜像文件硬盘安装方法]]></title>
    <link href="http://lygstate.github.com/blog/2013/01/13/install-windows-with-iso-image-by-the-help-of-grub/"/>
    <updated>2013-01-13T03:06:00+08:00</updated>
    <id>http://lygstate.github.com/blog/2013/01/13/install-windows-with-iso-image-by-the-help-of-grub</id>
    <content type="html"><![CDATA[<p><a href="http://bbs.wuyou.com/viewthread.php?tid=148722" title="Windows Vista/2008/7全系列（x86、x64）ISO镜像文件硬盘安装方法">Permalink</a></p>

<p>本方法适合<code>移动硬盘</code>、<code>硬盘</code>、<code>U盘</code>、<code>USB读卡器</code>等可启动介质安装 <code>Windows Vista</code>、 <code>Windows 2008</code>、 <code>Windows 7</code> 全系列（X86、AMD64）系统。本方法和DVD光驱安装没有太大的差别，只是启动和中间会用到grub4dos/ImDisk来虚拟光驱; 还有本文中选用ImDisk作虚拟光驱软件， 是因为自己在别的WinPE里接触过，在别的方面也常用，大家可以选择适合自己的来代替都是可以的， ImDisk是我在x86/x64（2008/win7）上都测试过的。下面以 <code>移动硬盘+win7p64.iso</code> 为例</p>

<h4><strong><code>软件需求：</code></strong></h4>

<ul>
<li><code>Windows ISO镜像</code>， 此例中为<code>win7p64.iso</code>。 Windows Vista、 Windows 2008、 Windows7 全系列（x86、x64）都可以; 推荐放置在硬盘/移动硬盘上（速度快），此例中放在<code>移动硬盘</code>中：</li>
<li><a href="http://download.gna.org/grubutil/grubinst-1.1-bin-w32-2008-01-01.zip">grubinst</a> 用于<code>移动硬盘</code>（或其其它安装盘）引导扇区的写入。</li>
<li><a href="http://download.gna.org/grub4dos/grub4dos-0.4.4-2009-06-20.zip">grub4dos</a> 需要做成可启动的，可放在 <code>移动硬盘</code>、<code>硬盘</code>、U盘、USB读卡器、光盘、pxe服务器上。<br/>
如果ISO文件在USB设备上，grub4dos也应该装在同一个设备（大家可以试一试别的，能找到ISO文件就行）</li>
<li><a href="http://www.ltr-data.se/opencode.html/#ImDisk">ImDisk</a> 直接下载原版；默认带有x86、x64驱动，所以可以直接用于x86、x64版本安装。</li>
<li><a href="http://technet.microsoft.com/en-us/Sysinternals/Bb897428.aspx">Contig</a> 使文件以连续的方式存储。</li>
</ul>


<h4><strong><code>安装示例：</code></strong></h4>

<p>为了方便抓图，这里在VMware里用第二块硬盘模拟<code>移动硬盘</code>操作，假设该移动硬盘只有一个分区，并且识别成盘符X:</p>

<h6><code>制作移动硬盘:</code></h6>

<ul>
<li>解压缩下载到的<a href="http://download.gna.org/grubutil/grubinst-1.1-bin-w32-2008-01-01.zip">grubinst</a>， 执行里面的<code>grubinst_gui.exe</code>（以管理员模式运行），选择要写入的<code>磁盘</code>（这里是<code>移动硬盘</code>）,点击<code>安装</code>。</li>
<li>解压缩下载到的<a href="http://download.gna.org/grub4dos/grub4dos-0.4.4-2009-06-20.zip">grub4dos</a>， 复制里面的文件到<code>移动硬盘X:</code>根目录下。删除根目录下的<code>menu.lst</code>(让其自动进入命令模式)</li>
<li>解压缩下载到的<a href="http://www.ltr-data.se/opencode.html/#ImDisk">ImDisk</a>; 如果是可执行文件，照样可以解压缩。复制里面的文件到<code>移动硬盘X:</code>根目录下</li>
<li>复制win7p64.iso到<code>移动硬盘X:</code>根目录</li>
<li><p>解压缩下载到的<a href="http://technet.microsoft.com/en-us/Sysinternals/Bb897428.aspx">Contig</a>，复制Contig.exe到<code>移动硬盘X:</code>根目录， 执行以下命令:</p>

<pre><code>  pushd X: (`移动硬盘X:`根目录)
  Contig.exe win7p64.iso
</code></pre>

<p>Contig.exe的意义是为了让win7p64.iso连续存储； grub4dos需要调用 <code>map /win7p64.iso</code>，而文件win7p64.iso比较大，故这里不准备在grub4dos里把它整个map到内存；因此必须保证它在磁盘上是连续存放的。</p></li>
</ul>


<h6><strong><code>移动硬盘结构:</code></strong></h6>

<pre><code>X:
│  badgrub.exe
│  bootlace.com
│  ChangeLog_GRUB4DOS.txt
│  config.sys
│  COPYING
│  default
│  Get_Source_of_This_Build.txt
│  gpl.txt
│  grldr
│  grldr.mbr
│  grub.exe
│  grub.pif
│  hmload.com
│  imdisk.inf
│  install.cmd
│  menu.lst
│  msgbox.exe
│  readme.txt
│  README_GRUB4DOS.txt
│  runwait.exe
│  win7p64.iso
│
├─awealloc
│  ├─amd64
│  │      awealloc.sys
│  │
│  ├─i386
│  │      awealloc.sys
│  │
│  └─ia64
│          awealloc.sys
│
├─chinese
│      badgrub.exe
│      grldr
│      grub.exe
│
├─cli
│  ├─amd64
│  │      imdisk.exe
│  │
│  ├─i386
│  │      imdisk.exe
│  │
│  └─ia64
│          imdisk.exe
│
├─cpl
│  ├─amd64
│  │      imdisk.cpl
│  │
│  ├─i386
│  │      imdisk.cpl
│  │
│  └─ia64
│          imdisk.cpl
│
├─svc
│  ├─amd64
│  │      imdsksvc.exe
│  │
│  ├─i386
│  │      imdsksvc.exe
│  │
│  └─ia64
│          imdsksvc.exe
│
└─sys
    ├─amd64
    │      imdisk.sys
    │
    ├─i386
    │      imdisk.sys
    │
    └─ia64
            imdisk.sys
</code></pre>

<h6><strong><code>安装操作系统:</code></strong></h6>

<ol>
<li>设置BIOS引导盘为<code>移动硬盘</code>（也可以是U盘或是其它安装盘); 启动电脑；进入到grub4dos界面；如下图所示（图1）：<br/>
<img src="http://lygstate.github.com/images/2013/01/13/grub-init-interface.png" alt="Grub Init Interface" /></li>
<li><p>在GRUB命令模式下执行以下命令：</p>

<pre><code> find --set-root /win7p64.iso  
 map /win7p64.iso (0xff)  
 map --hook  
 chainloader (0xff)  
 boot
</code></pre>

<p>执行情况如下图所示（图2）:<br/>
<img src="http://lygstate.github.com/images/2013/01/13/grub-commands.png" alt="Grub Commands" /></p></li>
<li>下面进入正常的Win7安装,直到下图所示界面（图3）:<br/>
<img src="http://lygstate.github.com/images/2013/01/13/grub-no-dvd-error.jpg" alt="No CD/DVD" /></li>
<li><p>上一步就因为找不到真实的光驱,所以报错,此时点击<code>Shift+F10</code>调出CMD窗口， 通过imdisk挂载<code>win7p64.iso</code>为虚拟光驱;执行以下一系列命令:</p>

<pre><code> pushd X: (您那里可能是E: F:，即VMware虚拟硬盘所在的盘符,此为注释)
 rundll32.exe setupapi.dll,InstallHinfSection DefaultInstall 132 .\imdisk.inf (安装驱动，稍等几秒,等待安装成功,很快的)  
 imdisk -a -f "win7p64.iso" -m #:
</code></pre>

<p>执行情况如下图所示:<br/>
<img src="http://lygstate.github.com/images/2013/01/13/grub-install-dvd.jpg" alt="Install Virtual DVD" /></p></li>
<li>执行完上一步,关闭cmd窗口,再关闭另外的可看到的那几个窗口,会返回到（图4）<br/>
<img src="http://lygstate.github.com/images/2013/01/13/grub-os-start-install.jpg" alt="Start Install OS" /></li>
<li>点击&#8221;现在安装&#8221;,以下就和DVD光盘安装一样了,后面在重新启动机器的时候可以拔掉移动硬盘或USB设备(防止再从安装盘启动)</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SFTP Access To Amazon EC2 Using FileZilla]]></title>
    <link href="http://lygstate.github.com/blog/2013/01/13/sftp-access-to-amazon-ec2-using-filezilla/"/>
    <updated>2013-01-13T02:48:00+08:00</updated>
    <id>http://lygstate.github.com/blog/2013/01/13/sftp-access-to-amazon-ec2-using-filezilla</id>
    <content type="html"><![CDATA[<p><a href="http://www.hermeswritings.com/index.php/2012/05/sftp-access-to-amazon-ec2-using-filezilla/" title="Permalink to SFTP Access To Amazon EC2 Using FileZilla « Hermes Writings">Permalink</a></p>

<p>After You can setup EC2 Instance on AWS next step is to upload files onto the server.</p>

<p>I have setup Ubunto instance and using Filezilla to connect to it after installation LAMP.</p>

<ul>
<li>Make sure port 22 is open in your instance’s Security Group in Amazon’s AWS site</li>
<li>Add .Pem Keys to FileZilla Click on <code>Edit &gt;&gt; setting &gt;&gt; SFTP &gt;&gt; Add Key File</code></li>
<li>Locate your PEM file. At this point FileZilla will ask if you want to convert it to a format it can use. Say <code>Yes</code> and tell it where to put the new .PPK file.</li>
<li>Close the Settings window.</li>
<li>Enter Host: like: <code>ec2-107-22-137-202.compute-1.amazonaws.com</code> or the <code>IP address</code>, user: <code>ubuntu</code> and port: <code>22</code>. Then click on Quick connect; It will connect with the following hints:</li>
</ul>


<p><img src="http://lygstate.github.com/images/2013/01/13/filezilla.jpg" alt="FileZilla Connection status" /></p>

<p><code>User name</code> might vary depending on your instance, by default ububtu instance username is ubuntu</p>

<p>Depending on the original AMI the instance is based on, you may want to double check that the correct user name is being used to authenticate.</p>

<p>Amazon Linux: <code>ec2-user</code><br/>
RHEL: <code>root</code><br/>
Ubuntu: <code>ubuntu</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting up FTP Server on Ubuntu - Amazon EC2]]></title>
    <link href="http://lygstate.github.com/blog/2013/01/13/setting-up-ftp-server-on-ubuntu-amazon-ec2/"/>
    <updated>2013-01-13T02:16:00+08:00</updated>
    <id>http://lygstate.github.com/blog/2013/01/13/setting-up-ftp-server-on-ubuntu-amazon-ec2</id>
    <content type="html"><![CDATA[<p><a href="http://curiousdeveloper.blogspot.com/2008/07/setting-up-ftp-server-on-ubuntu-amazon.html" title="Permalink to Setting up FTP Server on Ubuntu - Amazon EC2">Permalink</a></p>

<p>File Transfer Protocol (FTP) is a TCP protocol for uploading and downloading files between computers. FTP works on a client/server model. The server component is called an <em>FTP daemon</em>. It continuously listens for FTP requests from remote clients. When a request is received, it manages the the login and sets up the connection. For the duration of the session it executes any of commands sent by the FTP client.</p>

<p>Access to an FTP server can be managed in two ways:</p>

<p>In the Anonymous mode, remote clients can access the FTP server by using the default user account called &#8216;anonymous&#8221; or &#8220;ftp&#8221; and sending an email address as the password. In the Authenticated mode a user must have an account and a password. User access to the FTP server directories and files is dependent on the permissions defined for the account used at login. As a general rule, the FTP daemon will hide the root directory of the FTP server and change it to the FTP Home directory. This hides the rest of the file system from remote sessions.</p>

<h2>Amazon EC2: Unblock FTP port</h2>

<p>FTP works on port 21 by default. This port is blocked by the AWS firewall. You must unblock this port (21) by changing the instance permissions prior to setting up FTP so that you can access FTP remotely. This can be done using the AWS EC2 Elastic Fox client. Please refer to my other post about Unblocking ports on the Amazon EC2 for more details.</p>

<h2>vsftpd - FTP Server Installation</h2>

<p>vsftpd is an FTP daemon available in Ubuntu. It is easy to install, set up, and maintain. To install <strong>vsftpd</strong> you can run the following command:<br/>
<code>sudo apt-get install vsftpd</code></p>

<h2>vsftpd - FTP Server Configuration</h2>

<p>You can edit the vsftpd configuration file, <code>sudo vi /etc/vsftpd.conf</code>, to change the default settings. By default only anonymous FTP is allowed. If you wish to disable this option, you should change the following line:<br/>
<code>anonymous_enable=YES</code><br/>
to<br/>
<code>anonymous_enable=NO</code></p>

<p>By default, local system users are not allowed to login to FTP server. To change this setting, you should uncomment the following line:<br/>
<code>#local_enable=YES</code></p>

<p>By default, users are allowed to download files from FTP server. They are not allowed to upload files to FTP server. To change this setting, you should uncomment the following line:<br/>
<code>#write_enable=YES</code></p>

<p>Similarly, by default, the anonymous users are not allowed to upload files to FTP server. To change this setting, you should uncomment the following line:<br/>
<code>#anon\_upload\_enable=YES</code></p>

<p>The configuration file consists of many configuration parameters. The information about each parameter is available in the configuration file. Alternatively, you can refer to the man page, <strong>man 5 vsftpd.conf</strong> for details of each parameter.</p>

<p>Once you configure <strong>vsftpd</strong> you can start the daemon. You can run following command to run the <strong>vsftpd</strong> daemon:</p>

<p><code>sudo /etc/init.d/vsftpd start</code></p>

<p>Please note that the defaults in the configuration file are set as they are for security reasons. Each of the above changes makes the system a little less secure, so make them only if you need them.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Show All Running Processes in Linux]]></title>
    <link href="http://lygstate.github.com/blog/2013/01/13/show-all-running-processes-in-linux/"/>
    <updated>2013-01-13T00:01:00+08:00</updated>
    <id>http://lygstate.github.com/blog/2013/01/13/show-all-running-processes-in-linux</id>
    <content type="html"><![CDATA[<p><a href="http://www.cyberciti.biz/faq/show-all-running-processes-in-linux/" title="Permalink to Show All Running Processes in Linux">Permalink</a></p>

<p>How do I see all running process in Linux?</p>

<p>You need to use the ps command. It provide information about the currently running processes, including their process identification numbers (PIDs). Both Linux and UNIX support ps command to display information about all running process. ps command gives a snapshot of the current processes. If you want a repetitive update of this status, use top command.</p>

<h2>ps command</h2>

<p>Type the following <strong>ps command</strong> to display all running process:<br/>
<code># ps aux | less</code><br/>
Where,</p>

<ul>
<li>-A: select all processes</li>
<li>a: select all processes on a terminal, including those of other users</li>
<li>x: select processes without controlling ttys</li>
</ul>


<h2>Task: see every process on the system</h2>

<p><code># ps -A# ps -e</code></p>

<h2>Task: See every process except those running as root</h2>

<p><code># ps -U root -u root -N</code></p>

<h2>Task: See process run by user vivek</h2>

<p><code># ps -u vivek</code></p>

<h2>Task: top command</h2>

<p>The top program provides a dynamic real-time view of a running system. Type the top at command prompt:<br/>
<code># top</code><br/>
Output:</p>

<p><img src="http://lygstate.github.com/images/2013/01/13/linux-unix-top-command.png" alt="Fig.01: top command: Display Linux Tasks" /><br/>
Fig.01: top command: Display Linux Tasks</p>

<p>To quit press <strong>q</strong>, for help press <strong>h</strong>.</p>

<h3>Task: display a tree of processes</h3>

<p>pstree shows running processes as a tree. The tree is rooted at either pid or init if pid is omitted. If a user name is specified, all process trees rooted at processes owned by that user are shown.<br/>
<code>$ pstree</code><br/>
Sample outputs:</p>

<p><img src="http://lygstate.github.com/images/2013/01/13/linux-unix-pstree-command.png" alt="Fig.02: pstree - Display a tree of processes" /><br/>
Fig.02: pstree - Display a tree of processes</p>

<h3>Task: Print a process tree using ps</h3>

<p><code>#  ps -ejH# ps axjf</code></p>

<h3>Task: Get info about threads</h3>

<p>Type the following command:<br/>
<code># ps -eLf# ps axms</code></p>

<h3>Task: Get security info</h3>

<p>Type the following command:<br/>
<code># ps -eo euser,ruser,suser,fuser,f,comm,label# ps axZ# ps -eM</code></p>

<h3>Task: Save Process Snapshot to a file</h3>

<p>Type the following command:<br/>
<code># top -b -n1 &amp;gt; /tmp/process.log</code><br/>
Or you can email result to yourself:<br/>
<code># top -b -n1 | mail -s 'Process snapshot' you@example.com</code></p>

<h2>Task: Lookup process</h2>

<p>Use pgrep command. pgrep looks through the currently running processes and lists the process IDs which matches the selection criteria to screen. For example display firefox process id:<br/>
<code>$ pgrep firefox</code><br/>
Sample outputs:</p>

<pre><code>3356
</code></pre>

<p>Following command will list the process called sshd which is owned by a user called root:<br/>
<code>$ pgrep -u root sshd</code></p>

<h2>Say hello to htop and atop</h2>

<p>htop is interactive process viewer just like top, but allows to scroll the list vertically and horizontally to see all processes and their full command lines. Tasks related to processes (killing, renicing) can be done without entering their PIDs. To install htop type command:<br/>
<code># apt-get install htop</code><br/>
or<br/>
<code># yum install htop</code><br/>
Now type the htop command at the shell prompt:<br/>
<code># htop</code><br/>
Sample outputs:<br/>
<img src="http://lygstate.github.com/images/2013/01/13/linux-unix-htop-command.png" alt="Fig.03: htop - Interactive Linux / UNIX process viewer" /><br/>
Fig.03: htop - Interactive Linux / UNIX process viewer</p>

<h3>atop program</h3>

<p>The program atop is an interactive monitor to view the load on a Linux system. It shows the occupation of the most critical hardware resources (from a performance point of view) on system level, i.e. cpu, memory, disk and network. It also shows which processes are responsible for the indicated load with respect to cpu- and memory load on process level; disk- and network load is only shown per process if a kernel patch has been installed. Type the following command to start atop:<br/>
<code># atop</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building a SOCKS proxy on EC2]]></title>
    <link href="http://lygstate.github.com/blog/2013/01/12/building-a-socks-proxy-on-ec2/"/>
    <updated>2013-01-12T21:15:00+08:00</updated>
    <id>http://lygstate.github.com/blog/2013/01/12/building-a-socks-proxy-on-ec2</id>
    <content type="html"><![CDATA[<p><a href="http://eric.gerlach.ca/blog/2012/6/19/building-a-socks-proxy-on-ec2-to-get-around-wifi-port-blocki.html">Permalink</a></p>

<p>At the NXNE Mobile Hackathon, we ran into a small problem. The wifi set up in the room would only allow connections over HTTP and HTTPS, which made it impossible to do many things you might want to do at a hackathon, like:</p>

<ol>
<li>Push to GitHub over SSH</li>
<li>Connect to MongoDB instances</li>
<li>Connect to&#8230; anything&#8230; that isn&#8217;t on ports 80 or 443&#8230; so a lot.</li>
</ol>


<p>If you can configure your tools correctly, the easiest way to get around this kind of problem is via a SOCKS proxy. Normally, I&#8217;d set up an SSH tunnel and run the SOCKS proxy over that&#8230; but no SSH. So the next best thing is to get a SOCKS server running on EC2. Let&#8217;s go through the steps required to set this up so that if you end up in the same situation, you can help those around you.</p>

<p>Doing this assumes that you temporarily have an internet connection that is unrestricted, like a tethered smartphone or a wired connection. I&#8217;m also assuming that you know your way around EC2 a bit.</p>

<ol>
<li>Connect to your unrestricted internet connection</li>
<li>Login to EC2</li>
<li>Ensure that you have a keypair setup</li>
<li>Create an EC2 Security Group that opens ports 22 and 443 to the world</li>
<li>Fire up an Ubuntu 12.04 LTS instance (micro will usually do) with your keypair and Security Group</li>
<li>SSH into the new machine with the SSH key (default username: ubuntu)</li>
<li><p>Run the following commands at the prompt or in a shell script:</p>

<pre><code> sudo apt-get install build-essential
 wget http://www.inet.no/dante/files/dante-1.3.2.tar.gz # or another version
 tar -zxvf dante-1.3.2.tar.gz
 cd dante-1.3.2
 ./configure
 make
 sudo make install
 $ sudo make me a sandwich
</code></pre></li>
<li><p>Put the following config in /etc/sock.conf<br/>
 <strong>Notice:</strong><br/>
 When use <code>internal: 127.0.0.1 port = 7071</code>, then the proxy address <em>is</em> <code>127.0.0.1:7071</code>.<br/>
 When use <code>internal: eth0 port = 7071</code>, and the IP binded to <code>eth0</code> is <code>10.210.235.113</code>,
 then the proxy address <strong>is</strong> <code>10.210.235.113:7071</code>, it&#8217;s the only proxy address.</p>

<pre><code> logoutput: /var/log/danted.log
 # But, when use eth0 instead, the the proxy addresss will turn out to be
 # the IP that binded to eth0, support the IP binded to eth0 is ``
 internal: 127.0.0.1 port = 7071
 #internal: eth0 port = 7071
 external: eth0
 method: username none

 #user.privileged: root
 user.notprivileged: nobody

 client pass {
   from: 127.0.0.1/32 port 1-65535 to: 0.0.0.0/0
 }

 client pass {
   from: 127.0.0.0/8 port 1-65535 to: 0.0.0.0/0
 }

 client block {
   from: 0.0.0.0/0 to: 0.0.0.0/0
   log: connect error
 }

 block {
   from: 0.0.0.0/0 to: 127.0.0.0/8
   log: connect error
 }

 pass {
   from: 127.0.0.1/32 to: 0.0.0.0/0
   protocol: tcp udp
 }

 pass {
   from: 127.0.0.0/8 to: 0.0.0.0/0
   protocol: tcp udp
 }

 block {
   from: 0.0.0.0/0 to: 0.0.0.0/0
   log: connect error
 }
</code></pre></li>
<li><p>Run <code>sudo sockd -D</code></p></li>
</ol>


<p>Now that we&#8217;ve got the server running, we have to configure our clients to connect to it. Fortunately, this is relatively easy. If you&#8217;re on linux, run your programs with tsocks. On Windows or Mac, you can try Proxifier (never tried it myself). Remember that the proxy is on port 443.</p>

<p>If you&#8217;re using PuTTY, you can set your proxy under Connection &gt; Proxy.</p>

<p>This set of steps creates an open proxy that anyone can use to proxy to anywhere. Don&#8217;t leave it running unless you want really big EC2 bills.</p>

<p>In doing this, I realized that it would be even better to be able to do this via a VPN instead of a SOCKS proxy in order to get better Windows and Mac full capture support. I&#8217;m going to play with this idea and post again when I&#8217;ve got something.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Converting between different SSH private/public key formats.]]></title>
    <link href="http://lygstate.github.com/blog/2013/01/12/converting-between-different-ssh-private-slash-public-key-formats/"/>
    <updated>2013-01-12T16:00:00+08:00</updated>
    <id>http://lygstate.github.com/blog/2013/01/12/converting-between-different-ssh-private-slash-public-key-formats</id>
    <content type="html"><![CDATA[<h2>PuTTY &#8211;> SSH</h2>

<ul>
<li>PuTTY private key to SSH public key and private key.<br/>
<code>puttygen</code> supports exporting to an OpenSSH compatible format.

<ol>
<li>Open PuttyGen</li>
<li>Click Load</li>
<li>Load your private key</li>
<li>Go to <code>Conversions-&gt;Export OpenSSH</code> and export your private key</li>
<li>Copy your private key to <code>~/.ssh/id_dsa</code> (or <code>id_rsa</code>).</li>
<li>Create the RFC 4716 version of the public key using <code>ssh-keygen</code>:<br />
<code>ssh-keygen -e -f ~/.ssh/id_dsa &gt; ~/.ssh/id_dsa_com.pub</code></li>
<li>Convert the RFC 4716 version of the public key to the OpenSSH format:<br />
<code>ssh-keygen -i -f ~/.ssh/id_dsa_com.pub &gt; ~/.ssh/id_dsa.pub</code></li>
</ol>
</li>
<li>PuTTY public key to SSH public key<br/>
If all you have is a public key from a user in PuTTY-style format, you can convert it to standard openssh format like so:<br/>
<code>ssh-keygen -i -f keyfile.pub &gt; newkeyfile.pub</code></li>
</ul>


<p>See <a href="http://linux-sxs.org/networking/openssh.putty.html">this</a> and <a href="http://www.wellsi.com/sme/ssh/ssh.html">this</a> for more information.</p>
]]></content>
  </entry>
  
</feed>
