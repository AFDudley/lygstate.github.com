<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Octopress Blog]]></title>
  <link href="http://lygstate.github.com/atom.xml" rel="self"/>
  <link href="http://lygstate.github.com/"/>
  <updated>2013-01-13T01:36:44+08:00</updated>
  <id>http://lygstate.github.com/</id>
  <author>
    <name><![CDATA[Yonggang Luo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Show All Running Processes in Linux]]></title>
    <link href="http://lygstate.github.com/blog/2013/01/13/show-all-running-processes-in-linux/"/>
    <updated>2013-01-13T00:01:00+08:00</updated>
    <id>http://lygstate.github.com/blog/2013/01/13/show-all-running-processes-in-linux</id>
    <content type="html"><![CDATA[<p><a href="http://www.cyberciti.biz/faq/show-all-running-processes-in-linux/" title="Permalink to Show All Running Processes in Linux">Permalink</a></p>

<p>How do I see all running process in Linux?</p>

<p>You need to use the ps command. It provide information about the currently running processes, including their process identification numbers (PIDs). Both Linux and UNIX support ps command to display information about all running process. ps command gives a snapshot of the current processes. If you want a repetitive update of this status, use top command.</p>

<h2>ps command</h2>

<p>Type the following <strong>ps command</strong> to display all running process:<br/>
<code># ps aux | less</code><br/>
Where,</p>

<ul>
<li>-A: select all processes</li>
<li>a: select all processes on a terminal, including those of other users</li>
<li>x: select processes without controlling ttys</li>
</ul>


<h2>Task: see every process on the system</h2>

<p><code># ps -A# ps -e</code></p>

<h2>Task: See every process except those running as root</h2>

<p><code># ps -U root -u root -N</code></p>

<h2>Task: See process run by user vivek</h2>

<p><code># ps -u vivek</code></p>

<h2>Task: top command</h2>

<p>The top program provides a dynamic real-time view of a running system. Type the top at command prompt:<br/>
<code># top</code><br/>
Output:</p>

<p><img src="http://lygstate.github.com/images/2013/01/13/linux-unix-top-command.png" alt="Fig.01: top command: Display Linux Tasks" /><br/>
Fig.01: top command: Display Linux Tasks</p>

<p>To quit press <strong>q</strong>, for help press <strong>h</strong>.</p>

<h3>Task: display a tree of processes</h3>

<p>pstree shows running processes as a tree. The tree is rooted at either pid or init if pid is omitted. If a user name is specified, all process trees rooted at processes owned by that user are shown.<br/>
<code>$ pstree</code><br/>
Sample outputs:</p>

<p><img src="http://lygstate.github.com/images/2013/01/13/linux-unix-pstree-command.png" alt="Fig.02: pstree - Display a tree of processes" /><br/>
Fig.02: pstree - Display a tree of processes</p>

<h3>Task: Print a process tree using ps</h3>

<p><code>#  ps -ejH# ps axjf</code></p>

<h3>Task: Get info about threads</h3>

<p>Type the following command:<br/>
<code># ps -eLf# ps axms</code></p>

<h3>Task: Get security info</h3>

<p>Type the following command:<br/>
<code># ps -eo euser,ruser,suser,fuser,f,comm,label# ps axZ# ps -eM</code></p>

<h3>Task: Save Process Snapshot to a file</h3>

<p>Type the following command:<br/>
<code># top -b -n1 &amp;gt; /tmp/process.log</code><br/>
Or you can email result to yourself:<br/>
<code># top -b -n1 | mail -s 'Process snapshot' you@example.com</code></p>

<h2>Task: Lookup process</h2>

<p>Use pgrep command. pgrep looks through the currently running processes and lists the process IDs which matches the selection criteria to screen. For example display firefox process id:<br/>
<code>$ pgrep firefox</code><br/>
Sample outputs:</p>

<pre><code>3356
</code></pre>

<p>Following command will list the process called sshd which is owned by a user called root:<br/>
<code>$ pgrep -u root sshd</code></p>

<h2>Say hello to htop and atop</h2>

<p>htop is interactive process viewer just like top, but allows to scroll the list vertically and horizontally to see all processes and their full command lines. Tasks related to processes (killing, renicing) can be done without entering their PIDs. To install htop type command:<br/>
<code># apt-get install htop</code><br/>
or<br/>
<code># yum install htop</code><br/>
Now type the htop command at the shell prompt:<br/>
<code># htop</code><br/>
Sample outputs:<br/>
<img src="http://lygstate.github.com/images/2013/01/13/linux-unix-htop-command.png" alt="Fig.03: htop - Interactive Linux / UNIX process viewer" /><br/>
Fig.03: htop - Interactive Linux / UNIX process viewer</p>

<h3>atop program</h3>

<p>The program atop is an interactive monitor to view the load on a Linux system. It shows the occupation of the most critical hardware resources (from a performance point of view) on system level, i.e. cpu, memory, disk and network. It also shows which processes are responsible for the indicated load with respect to cpu- and memory load on process level; disk- and network load is only shown per process if a kernel patch has been installed. Type the following command to start atop:<br/>
<code># atop</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building a SOCKS proxy on EC2]]></title>
    <link href="http://lygstate.github.com/blog/2013/01/12/building-a-socks-proxy-on-ec2/"/>
    <updated>2013-01-12T21:15:00+08:00</updated>
    <id>http://lygstate.github.com/blog/2013/01/12/building-a-socks-proxy-on-ec2</id>
    <content type="html"><![CDATA[<p><a href="http://eric.gerlach.ca/blog/2012/6/19/building-a-socks-proxy-on-ec2-to-get-around-wifi-port-blocki.html">Permalink</a></p>

<p>At the NXNE Mobile Hackathon, we ran into a small problem. The wifi set up in the room would only allow connections over HTTP and HTTPS, which made it impossible to do many things you might want to do at a hackathon, like:</p>

<ol>
<li>Push to GitHub over SSH</li>
<li>Connect to MongoDB instances</li>
<li>Connect to&#8230; anything&#8230; that isn&#8217;t on ports 80 or 443&#8230; so a lot.</li>
</ol>


<p>If you can configure your tools correctly, the easiest way to get around this kind of problem is via a SOCKS proxy. Normally, I&#8217;d set up an SSH tunnel and run the SOCKS proxy over that&#8230; but no SSH. So the next best thing is to get a SOCKS server running on EC2. Let&#8217;s go through the steps required to set this up so that if you end up in the same situation, you can help those around you.</p>

<p>Doing this assumes that you temporarily have an internet connection that is unrestricted, like a tethered smartphone or a wired connection. I&#8217;m also assuming that you know your way around EC2 a bit.</p>

<ol>
<li>Connect to your unrestricted internet connection</li>
<li>Login to EC2</li>
<li>Ensure that you have a keypair setup</li>
<li>Create an EC2 Security Group that opens ports 22 and 443 to the world</li>
<li>Fire up an Ubuntu 12.04 LTS instance (micro will usually do) with your keypair and Security Group</li>
<li>SSH into the new machine with the SSH key (default username: ubuntu)</li>
<li><p>Run the following commands at the prompt or in a shell script:
 sudo apt-get install build-essential
 wget http://www.inet.no/dante/files/dante-1.3.2.tar.gz # or another version
 tar -zxvf dante-1.3.2.tar.gz
 cd dante-1.3.2
 ./configure
 make
 sudo make install
 $ sudo make me a sandwich</p></li>
<li><p>Put the following config in /etc/sock.conf
 ## general configuration (taken from FAQ)</p>

<p> internal: eth0 port = 443
 external: eth0
 method: username none
 user.privileged: root
 user.unprivileged: nobody
 logoutput: stderr</p>

<p> ## client access rules</p>

<p> client pass { from: 0.0.0.0/0 to: 0.0.0.0/0 } # address-range on internal nic.</p>

<p> ## server operation access rules</p>

<p> # block connections to localhost, or they will appear to come from the proxy.
 block { from: 0.0.0.0/0 to: lo log: connect }</p>

<p> # allow the rest
 pass { from: 0.0.0.0/0 to: 0.0.0.0/0 }</p></li>
<li><p>Run <code>sudo sockd -D</code></p></li>
</ol>


<p>Now that we&#8217;ve got the server running, we have to configure our clients to connect to it. Fortunately, this is relatively easy. If you&#8217;re on linux, run your programs with tsocks. On Windows or Mac, you can try Proxifier (never tried it myself). Remember that the proxy is on port 443.</p>

<p>If you&#8217;re using PuTTY, you can set your proxy under Connection &gt; Proxy.</p>

<p>This set of steps creates an open proxy that anyone can use to proxy to anywhere. Don&#8217;t leave it running unless you want really big EC2 bills.</p>

<p>In doing this, I realized that it would be even better to be able to do this via a VPN instead of a SOCKS proxy in order to get better Windows and Mac full capture support. I&#8217;m going to play with this idea and post again when I&#8217;ve got something.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Converting between different SSH private/public key formats.]]></title>
    <link href="http://lygstate.github.com/blog/2013/01/12/converting-between-different-ssh-private-slash-public-key-formats/"/>
    <updated>2013-01-12T16:00:00+08:00</updated>
    <id>http://lygstate.github.com/blog/2013/01/12/converting-between-different-ssh-private-slash-public-key-formats</id>
    <content type="html"><![CDATA[<h2>PuTTY &#8211;> SSH</h2>

<ul>
<li>PuTTY private key to SSH public key and private key.<br/>
<code>puttygen</code> supports exporting to an OpenSSH compatible format.

<ol>
<li>Open PuttyGen</li>
<li>Click Load</li>
<li>Load your private key</li>
<li>Go to <code>Conversions-&gt;Export OpenSSH</code> and export your private key</li>
<li>Copy your private key to <code>~/.ssh/id_dsa</code> (or <code>id_rsa</code>).</li>
<li>Create the RFC 4716 version of the public key using <code>ssh-keygen</code>:<br />
<code>ssh-keygen -e -f ~/.ssh/id_dsa &gt; ~/.ssh/id_dsa_com.pub</code></li>
<li>Convert the RFC 4716 version of the public key to the OpenSSH format:<br />
<code>ssh-keygen -i -f ~/.ssh/id_dsa_com.pub &gt; ~/.ssh/id_dsa.pub</code></li>
</ol>
</li>
<li>PuTTY public key to SSH public key<br/>
If all you have is a public key from a user in PuTTY-style format, you can convert it to standard openssh format like so:<br/>
<code>ssh-keygen -i -f keyfile.pub &gt; newkeyfile.pub</code></li>
</ul>


<p>See <a href="http://linux-sxs.org/networking/openssh.putty.html">this</a> and <a href="http://www.wellsi.com/sme/ssh/ssh.html">this</a> for more information.</p>
]]></content>
  </entry>
  
</feed>
